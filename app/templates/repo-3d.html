<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFM 3D Viewer</title>
    <link rel="stylesheet" href="/static/css/view3d.css">

    <script src="https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Cesium.js"></script>
    <script src="/static/js/lib_3d.js"></script>
    <script src="/static/config/project.js"></script>
    <script src="/static/config/repository_config.js"></script>

</head>

<body>
    <div id="northArrow"></div>
    <div id="cesiumContainer"></div>
    <div id="legend"></div>
    <div id="toggleButton"><span style="color: red;">&#9660;&nbsp;</span>Show/Hide Controls</div>

    <div id="controlContainer" style="display:none;">

        <div id="toggleGlobeContainer">
            <label>
                <input type="checkbox" id="toggleGlobeCheckbox">Imagery layer
            </label>
            <label>
                <input type="checkbox" id="toggleTerrainOcclusionCheckbox" checked> Terrain
                Occlusion
            </label>
        </div>
        <div id="toggleCFMTraceInterface">
            <label>
                <input type="checkbox" id="toggleCFMTraceCheckbox" checked> CFM traces
            </label>
            <label>
                <input type="checkbox" id="toggleCFMCheckbox" checked> CFM surfaces
            </label>
        </div>

        <!--Not displaying since we have moved the select option to the parent document.-->
        <div id="toggleSubductionInterface" style="display:none;">
            <!-- Visible checkbox with label -->
            <div>
                <input type="checkbox" id="toggle2dSurfaceCheckbox">
                <label for="toggle2dSurfaceCheckbox">Clear 2D Surfaces</label>
            </div>
            <div style="font-weight:bold;padding-top: 10px;">Select 2D Surfaces:</div>
            <select id="select2dSurface" multiple size="5"></select>
            </select>
        </div>


        <div id="toggleBoundaryInterface">
            <label>
                <input type="checkbox" id="toggleBoundaryCheckbox" checked> US &amp; Canada
            </label>
        </div>
        <div id="eqcontrols">
            <label><input type="checkbox" id="showEarthquakesCheckbox" checked>
                Earthquakes</label>
            <br>
            <label>Circle Size: <input type="range" id="circleSizeSlider" min="0" max="0.2" step="0.01"
                    value="0.04"></label>
        </div>

        <!-- Center View Button -->
        <div>
            <button id="centeredViewButton">Centered View</button>
            <label for="centerCoordinates">@</label>
            <input type="text" id="centerCoordinates" style="width:70px;" value="-123.0,45.5" />
            <button id="homeViewButton">Tilted View</button>
        </div>
        <!-- Slider controls for model boundaries -->
        <div>
            <hr style="border-top: 1px solid #0000FF" />
        </div>
        <div style="display:none;">
            <label for="data-file" style=" font-weight: bold;">CVM:</label>
            <select id="data-file" name="data_file"></select>
        </div>
        <div style=" font-weight: bold;">Latitude:</div>
        <div class="sliderContainer">
            <label class="sliderLabel">Min.: <input type="range" id="minLatSlider" min="47" max="50.9" step="0.1"
                    value="47"></label>
            <span id="minLatValue">47</span>
        </div>
        <div class="sliderContainer">
            <label class="sliderLabel">Max.: <input type="range" id="maxLatSlider" min="47" max="50.9" step="0.1"
                    value="50.9"></label>
            <span id="maxLatValue">50.9</span>
        </div>
        <div style=" font-weight: bold;">Longitude:</div>
        <div class="sliderContainer">
            <label class="sliderLabel">Min.: <input type="range" id="minLonSlider" min="-126" max="-121.1" step="0.1"
                    value="-126"></label>
            <span id="minLonValue">-126</span>
        </div>
        <div class="sliderContainer">
            <label class="sliderLabel">Max.: <input type="range" id="maxLonSlider" min="-126" max="-121.1" step="0.1"
                    value="-121.1"></label>
            <span id="maxLonValue">-121.1</span>
        </div>
        <div style="font-weight: bold;">Depth (km):</div>
        <div class="sliderContainer">
            <label class="sliderLabel">Min.: <input type="range" id="minDepthSlider" min="0" max="93" step="1"
                    value="0"></label>
            <span id="minDepthValue">0</span>
        </div>
        <div class="sliderContainer">
            <label class="sliderLabel">Max.: <input type="range" id="maxDepthSlider" min="0" max="93" step="1"
                    value="93"></label>
            <span id="maxDepthValue">93</span>
        </div>
        <div class="sliderContainer">
            <label class="sliderLabel" style=" font-weight: bold;">Grid Opacity:
                <input type="range" id="gridTransparencySlider" min="0" max="1" step="0.1" value="0.3">
            </label>
            <span id="gridTransparencyValue">0.3</span>
        </div>
        <div class="sliderContainer">
            <label class="sliderLabel" style=" font-weight: bold;">Selection Opacity: <input type="range"
                    id="alphaSlider" min="0" max="1" step="0.1" value="0.3"></label>
            <span id="alphaValue">0.3</span>
        </div>
    </div>
    <div id="mapControls">
        <div id="logoContainer">
            <img src="" alt="Logo" id="logo-image">
        </div>
        <b><i>Color Legend:</i></b>
        <div id="legendContainer"></div>
        <div id="auxLegendContainer"></div>
        <div id="distanceControl">
            <label><input type="checkbox" id="clearCheckbox"> Measure Distance</label>
            <div id="distanceDisplay">Click distances will appear here</div>
        </div>
    </div>

    <script>



        // Load the logo after the HTML is loaded.
        document.addEventListener('DOMContentLoaded', function () {
            // Select the image element by its ID
            const logoImage = document.getElementById('logo-image');

            // Set the src attribute to the desired image URL
            logoImage.src = logoFile;
        });


        // Initialize the viewer
        var viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider: new Cesium.IonImageryProvider({ assetId: 3954 }),
            depthPlaneEllipsoidOffset: 10000,
            nearToFarRatio: 1e6,
            farToNearRatio: 1e-6,
            sceneMode: Cesium.SceneMode.SCENE3D,
            skyBox: false, // Disable default skybox
            skyAtmosphere: false, // Disable sky atmosphere
            scene3DOnly: true,
            enableCollisionDetection: false,
            navigationInstructionsInitiallyVisible: true,
            baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3954)),
            globe: new Cesium.Globe(Cesium.Ellipsoid.WGS84, {
                minimumZoomDistance: 0.0
            })
        });

        // Set background color to black
        viewer.scene.backgroundColor = Cesium.Color.BLACK;

        // The north arrow.
        function updateNorthArrow() {
            var heading = Cesium.Math.toDegrees(viewer.camera.heading);
            //console.log('Camera Heading: ', heading);  // Debug log to check heading
            document.getElementById('northArrow').style.transform = 'rotate(' + (-heading) + 'deg)';
        }
        // Ensure update on initial load
        updateNorthArrow();

        // Bind updateNorthArrow to the postRender event
        viewer.scene.postRender.addEventListener(updateNorthArrow);

        // Center view button functionality
        document.getElementById('centeredViewButton').addEventListener('click', centeredView);
        function centeredView() {
            // Get the coordinates from the input box
            const coordinates = document.getElementById('centerCoordinates').value.split(',');
            const lon = parseFloat(coordinates[0]);
            const lat = parseFloat(coordinates[1]);

            // Calculate the bounding box dimensions
            const width = east - west;
            const height = north - south;
            const maxDimension = Math.max(width, height);
            const zoomOutFactor = 2.0; // Increased zoom out factor for better visibility

            // Estimate height based on the bounding box size
            const estimatedHeight = maxDimension * 111000 * zoomOutFactor; // 111,000 meters per degree

            // Move the camera to the new coordinates with the estimated height
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(lon, lat, estimatedHeight),
                orientation: {
                    heading: 0.0,
                    pitch: Cesium.Math.toRadians(-90.0), // Looking straight down
                    roll: 0.0
                }
            });
        };

        centeredView()


        // Hide/open the menu button
        document.getElementById('toggleButton').addEventListener('click', function () {
            var controlContainer = document.getElementById('controlContainer');
            var toggleButton = document.getElementById('toggleButton');
            // Get the actual styles applied
            const controlContainerDisplay = window.getComputedStyle(controlContainer).display
            if (controlContainerDisplay === 'none' || controlContainerDisplay === '') {
                controlContainer.style.display = 'block';
                toggleButton.innerHTML = '▲ Show/Hide Controls'; // Up arrow
            } else {
                controlContainer.style.display = 'none';
                toggleButton.innerHTML = '▼ Show/Hide Controls'; // Down arrow
            }
        });

        // Function to read and clear an item from localStorage
        function readAndClearLocalStorageItem(key) {
            // Step 1: Read the item from localStorage
            const item = localStorage.getItem(key);

            // Step 2: Remove the item from localStorage
            localStorage.removeItem(key);

            // Step 3: Return the parsed item, or null if it doesn't exist
            return item !== null ? JSON.parse(item) : null;
        }

        // Home view.
        function homeView() {
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(initialFlyTO[0], initialFlyTO[1], initialFlyTO[2]),
                orientation: {
                    heading: Cesium.Math.toRadians(initialHeading),
                    pitch: Cesium.Math.toRadians(initialPitch),
                    roll: initialRoll
                }
            });
        }

        // Override the home button functionality
        viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
            e.cancel = true; // Prevent the default home button action
            centeredView()

        });

        // Add the home button functionality
        document.getElementById("homeViewButton").addEventListener('click', function () {
            homeView()

        });

        viewer.scene.globe.frontFaceAlphaByDistance = new Cesium.NearFarScalar(50.0, 0.0, 100.0, 1.0);
        viewer.scene.globe.show = false;
        viewer.scene.fog.enabled = false;
        viewer.scene.globe.showGroundAtmosphere = false;
        viewer.scene.globe.depthTestAgainstTerrain = true;

        const toggleTerrainOcclusionCheckbox = document.getElementById('toggleTerrainOcclusionCheckbox');
        toggleTerrainOcclusionCheckbox.addEventListener('change', function () {
            viewer.scene.globe.depthTestAgainstTerrain = toggleTerrainOcclusionCheckbox.checked;
        });

        viewer.scene.setTerrain(new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromIonAssetId(2426648)));
        const scene = viewer.scene;
        const globe = scene.globe;
        const camera = scene.camera;

        scene.fog.enabled = false;
        globe.showGroundAtmosphere = false;
        globe.enableLighting = true;

        scene.light = new Cesium.DirectionalLight({
            direction: new Cesium.Cartesian3(1, 0, 0),
        });

        const scratchNormal = new Cesium.Cartesian3();
        scene.preRender.addEventListener(function (scene, time) {
            const surfaceNormal = globe.ellipsoid.geodeticSurfaceNormal(camera.positionWC, scratchNormal);
            const negativeNormal = Cesium.Cartesian3.negate(surfaceNormal, surfaceNormal);
            scene.light.direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.add(negativeNormal, camera.rightWC, surfaceNormal), scene.light.direction);
        });

        globe.maximumScreenSpaceError = 1.0;
        viewer.scene.backgroundColor = new Cesium.Color(0.0, 0.0, 0.0, 0.0);

        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(initialFlyTO[0], initialFlyTO[1], initialFlyTO[2]),
            orientation: {
                heading: Cesium.Math.toRadians(initialHeading),
                pitch: Cesium.Math.toRadians(initialPitch),
                roll: initialRoll
            }
        });

        viewer.scene.globe.baseColor = Cesium.Color.TRANSPARENT;
        viewer.animation.container.style.visibility = 'hidden';
        viewer.timeline.container.style.visibility = 'hidden';

        var dataSources = [];
        var boundaryDataSources = [];


        // Really need only one variable, but my attempts at merging them was drawing extra diagonal line.

        async function loadDropdown() {
            try {
                const response = await fetch('/models_drop_down');
                if (response.ok) {
                    const dropdownHTML = await response.text();
                    document.getElementById('data-file').innerHTML = dropdownHTML;
                } else {
                    console.error('Failed to load dropdown:', response.statusText);
                    document.getElementById('data-file').textContent = 'Failed to load dropdown.';
                }
            } catch (error) {
                console.error('Error fetching dropdown:', error);
                document.getElementById('data-file').textContent = 'Error loading dropdown.';
            }
        }

        // Call loadDropdown when the page has finished loading
        document.addEventListener('DOMContentLoaded', loadDropdown);

        // Earthquakes.
        async function loadEarthquakeData(url) {
            try {
                const dataSource = await Cesium.GeoJsonDataSource.load(url, {
                    clampToGround: false
                });
                earthquakeDataSource = dataSource;
                viewer.dataSources.add(dataSource);
                updateEarthquakeVisibility();

                const entities = dataSource.entities.values;
                const circleSizeSlider = document.getElementById('circleSizeSlider');
                entities.forEach(function (entity) {
                    entity.billboard = undefined;
                    if (entity.position) {
                        let coordinates = Cesium.Cartographic.fromCartesian(entity.position.getValue(Cesium.JulianDate.now()));
                        let depthInMeters = coordinates.height * 1000;
                        entity.position = new Cesium.ConstantPositionProperty(Cesium.Cartesian3.fromDegrees(
                            Cesium.Math.toDegrees(coordinates.longitude),
                            Cesium.Math.toDegrees(coordinates.latitude),
                            -depthInMeters
                        ));
                    }
                    entity.point = new Cesium.PointGraphics({
                        pixelSize: calculateMarkerSize(circleSizeSlider.value, entity.properties.mag.getValue()),
                        color: eqColor
                    });
                });
            } catch (error) {
                console.log('Error loading earthquake data:', error);
            }
        }

        // Earthquakes
        loadEarthquakeData(eqQueryUrl + south + '&maxlatitude=' + north + '&minlongitude=' + west + '&maxlongitude=' + east);

        function updateEarthquakeVisibility() {
            if (earthquakeDataSource) {
                var showEarthquakes = document.getElementById('showEarthquakesCheckbox').checked;
                earthquakeDataSource.show = showEarthquakes;
            }
        }

        document.getElementById('showEarthquakesCheckbox').addEventListener('change', updateEarthquakeVisibility);

        function calculateMarkerSize(baseSize, magnitude) {
            const scaleFactor = 3;
            return baseSize * Math.pow(magnitude, scaleFactor);
        }

        document.getElementById('circleSizeSlider').addEventListener('input', function () {
            if (earthquakeDataSource) {
                var entities = earthquakeDataSource.entities.values;
                entities.forEach(function (entity) {
                    entity.point = new Cesium.PointGraphics({
                        color: eqColor,
                        pixelSize: calculateMarkerSize(circleSizeSlider.value, entity.properties.mag)
                    });
                });
            }
        });

        // Draw a polygon showing the study area
        // Create the positions for the polygon
        const positions = Cesium.Cartesian3.fromDegreesArray([
            west, north,
            east, north,
            east, south,
            west, south
        ]);

        // Get the grid slider elements
        const gridTransparencySlider = document.getElementById('gridTransparencySlider');
        const gridTransparencyValue = document.getElementById('gridTransparencyValue');

        // Update the grid transparency when the slider is moved
        gridTransparencySlider.addEventListener('input', function () {
            gridTransparency = parseFloat(gridTransparencySlider.value); // Update transparency value
            gridTransparencyValue.textContent = gridTransparency; // Display the value

            // Redraw the grid lines with the updated transparency
            addGridLines(west, east, south, north);
        });


        // Call the function to add grid lines
        addGridLines(west, east, south, north);

        // Initialize the slider with the current transparency value
        gridTransparencySlider.value = gridTransparency;
        gridTransparencyValue.textContent = gridTransparency;

        // Add the polygon entity to the viewer
        viewer.entities.add({
            name: "study area",
            polygon: {
                hierarchy: new Cesium.PolygonHierarchy(positions),
                material: cvmAreaFaceColor[0].withAlpha(cvmAreaFillOpacity[0]), // Cyan color with 50% transparency
                perPositionHeight: true, // Allow different heights for each vertex
                outline: true,
                outlineColor: cvmAreaOutlineColor[0]
            }
        });
        //filterOutline(west + 2, east + 2, north + 2, south + 2, 2)
        function filterOutline(cornerN, cornerS, cornerE, cornerW, lw, polylineId, colorIndex) {

            // Check if the polyline already exists
            const existingEntity = viewer.entities.getById(polylineId);

            if (existingEntity) {
                // If the polyline exists, remove it
                viewer.entities.remove(existingEntity);
            }

            // If the polyline does not exist, add it if the colorIndex is not negative.
            if (colorIndex >= 0) {

                // Create the positions for the polyline
                const positions = Cesium.Cartesian3.fromDegreesArray([
                    cornerW, cornerN,
                    cornerE, cornerN,
                    cornerE, cornerS,
                    cornerW, cornerS
                ]);

                // Add a polyline entity to create the dashed outline
                viewer.entities.add({
                    id: polylineId, // Use the unique identifier
                    name: "study area outline",
                    polyline: {
                        positions: [...positions, positions[0]], // Close the loop by adding the first position again
                        width: lw, // Set the width of the dashed line
                        material: new Cesium.PolylineDashMaterialProperty({
                            color: cesiumColorList[colorIndex],
                            dashLength: 16.0, // Length of the dash pattern
                            gapColor: Cesium.Color.TRANSPARENT // Transparent gap between dashes
                        })
                    }
                });
            }

        }




        // Define the corner coordinates with labels
        const corners = [
            { lon: west, lat: north, label: 'NW', coordinates: `${west.toFixed(1)}, ${north.toFixed(1)}` },
            { lon: east, lat: north, label: 'NE', coordinates: `${east.toFixed(1)}, ${north.toFixed(1)}` },
            { lon: east, lat: south, label: 'SE', coordinates: `${east.toFixed(1)}, ${south.toFixed(1)}` },
            { lon: west, lat: south, label: 'SW', coordinates: `${west.toFixed(1)}, ${south.toFixed(1)}` }
        ];

        // Add labels to each corner
        corners.forEach(corner => {
            viewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(corner.lon, corner.lat),
                point: {
                    pixelSize: 10,
                    color: Cesium.Color.RED
                },
                label: {
                    text: `${corner.label}\n${corner.coordinates}`,
                    font: '14pt sans-serif',
                    fillColor: Cesium.Color.YELLOW,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -20) // Adjust label position
                }
            });
        });

        // Primary legends.
        var legendContainer = document.getElementById('legendContainer');
        primaryLegendLabel.forEach(function (labelText, i) {
            var legendItem = document.createElement('div');
            legendItem.classList.add('legendItem');

            var legendColor = document.createElement('div');
            legendColor.classList.add('legendColor');
            legendColor.style.backgroundColor = primaryLegendColor[i].toCssColorString();

            var legendLabel = document.createElement('span');
            legendLabel.textContent = labelText;

            legendItem.appendChild(legendColor);
            legendItem.appendChild(legendLabel);
            legendContainer.appendChild(legendItem);
        });

        // Auxiliary legends.
        var auxLegendContainer = document.getElementById('auxLegendContainer');
        auxLegendColor.forEach(function (color, i) {
            var legendItem = document.createElement('div');
            legendItem.classList.add('legendItem');

            var legendColor = document.createElement('div');
            legendColor.classList.add('legendColor');
            legendColor.style.backgroundColor = color.toCssColorString();

            var legendLabel = document.createElement('span');
            legendLabel.textContent = auxLegendLabel[i];

            legendItem.appendChild(legendColor);
            legendItem.appendChild(legendLabel);
            auxLegendContainer.appendChild(legendItem);
        });

        // Load the CVM models to the drop-down.
        async function loadDropdown() {
            try {
                const response = await fetch('/models_drop_down_coverage');
                if (response.ok) {
                    const dropdownHTML = await response.text();

                    document.getElementById('data-file').innerHTML = dropdownHTML;
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load dropdown:', response.statusText);
                    document.getElementById('data-file').textContent = 'Failed to load dropdown.';
                }
            } catch (error) {
                console.error('Error fetching dropdown:', error);
                document.getElementById('data-file').textContent = 'Error loading dropdown.';
            }
        }

        // Call loadDropdown when the page has finished loading
        document.addEventListener('DOMContentLoaded', loadDropdown);

        // Outline box for CVM.
        function updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha) {
            const minDepthScaled = minDepth * -1000;
            const maxDepthScaled = maxDepth * -1000;

            const topPositions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepthScaled,
                maxLon, minLat, minDepthScaled,
                maxLon, maxLat, minDepthScaled,
                minLon, maxLat, minDepthScaled
            ]);

            const bottomPositions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, maxDepthScaled,
                maxLon, minLat, maxDepthScaled,
                maxLon, maxLat, maxDepthScaled,
                minLon, maxLat, maxDepthScaled
            ]);

            const northPositions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, maxLat, minDepthScaled,
                maxLon, maxLat, minDepthScaled,
                maxLon, maxLat, maxDepthScaled,
                minLon, maxLat, maxDepthScaled
            ]);

            const southPositions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepthScaled,
                maxLon, minLat, minDepthScaled,
                maxLon, minLat, maxDepthScaled,
                minLon, minLat, maxDepthScaled
            ]);

            const eastPositions = Cesium.Cartesian3.fromDegreesArrayHeights([
                maxLon, minLat, minDepthScaled,
                maxLon, maxLat, minDepthScaled,
                maxLon, maxLat, maxDepthScaled,
                maxLon, minLat, maxDepthScaled
            ]);

            const westPositions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepthScaled,
                minLon, maxLat, minDepthScaled,
                minLon, maxLat, maxDepthScaled,
                minLon, minLat, maxDepthScaled
            ]);

            // Helper function to create and add polygon entity
            function addPolygonEntity(positions, alpha, name) {
                return viewer.entities.add({
                    name: name,
                    polygon: {
                        hierarchy: new Cesium.PolygonHierarchy(positions),
                        material: cvmFaceColor.withAlpha(alpha),
                        perPositionHeight: true, // Allow different heights for each vertex
                        outline: true,
                        outlineColor: cvmOutlineColor,
                    }
                });
                // Add a polyline entity for a thicker outline with transparency
                viewer.entities.add({
                    name: name + " outline",
                    polyline: {
                        positions: positions,
                        width: cvmLineWidth[0], // Set the width of the outline
                        material: cvmOutlineColor.withAlpha(1.0)
                    }
                });
            }

            // Remove existing entities if they exist
            if (boxEntities) {
                boxEntities.forEach(entity => viewer.entities.remove(entity));
            }
            boxEntities = [];

            // Add polygons for all six faces
            boxEntities.push(addPolygonEntity(topPositions, alpha, 'Top Surface'));
            boxEntities.push(addPolygonEntity(bottomPositions, alpha, 'Bottom Surface'));
            boxEntities.push(addPolygonEntity(northPositions, alpha, 'North Surface'));
            boxEntities.push(addPolygonEntity(southPositions, alpha, 'South Surface'));
            boxEntities.push(addPolygonEntity(eastPositions, alpha, 'East Surface'));
            boxEntities.push(addPolygonEntity(westPositions, alpha, 'West Surface'));
        }


        // Array to keep track of the box entities
        let boxEntities = [];


        // Sliders.
        function updateSlidersFromDropdown() {
            const coords = document.getElementById('data-file').value;

            if (coords.length > 0) {
                const limits = coords.replace(/[()]/g, '').split(',');
                const minLonSlider = document.getElementById('minLonSlider');
                const maxLonSlider = document.getElementById('maxLonSlider');
                const minLatSlider = document.getElementById('minLatSlider');
                const maxLatSlider = document.getElementById('maxLatSlider');
                const minDepthSlider = document.getElementById('minDepthSlider');
                const maxDepthSlider = document.getElementById('maxDepthSlider');

                minLonSlider.min = parseFloat(limits[0]);
                minLonSlider.max = parseFloat(limits[1]);
                minLonSlider.value = parseFloat(limits[0]);
                document.getElementById('minLonValue').textContent = minLonSlider.value;

                maxLonSlider.min = parseFloat(limits[0]);
                maxLonSlider.max = parseFloat(limits[1]);
                maxLonSlider.value = parseFloat(limits[1]);
                document.getElementById('maxLonValue').textContent = maxLonSlider.value;

                minLatSlider.min = parseFloat(limits[2]);
                minLatSlider.max = parseFloat(limits[3]);
                minLatSlider.value = parseFloat(limits[2]);
                document.getElementById('minLatValue').textContent = minLatSlider.value;

                maxLatSlider.min = parseFloat(limits[2]);
                maxLatSlider.max = parseFloat(limits[3]);
                maxLatSlider.value = parseFloat(limits[3]);
                document.getElementById('maxLatValue').textContent = maxLatSlider.value;

                minDepthSlider.min = parseFloat(limits[4]);
                minDepthSlider.max = parseFloat(limits[5]);
                minDepthSlider.value = parseFloat(limits[4]);
                document.getElementById('minDepthValue').textContent = minDepthSlider.value;

                maxDepthSlider.min = parseFloat(limits[4]);
                maxDepthSlider.max = parseFloat(limits[5]);
                maxDepthSlider.value = parseFloat(limits[5]);
                document.getElementById('maxDepthValue').textContent = maxDepthSlider.value;

                updateBoxOutline(parseFloat(minLatSlider.value), parseFloat(maxLatSlider.value), parseFloat(minLonSlider.value), parseFloat(maxLonSlider.value), parseFloat(minDepthSlider.value), parseFloat(maxDepthSlider.value), parseFloat(document.getElementById('alphaSlider').value));
            } else {
                if (boxEntities) {
                    boxEntities.forEach(entity => viewer.entities.remove(entity));
                }
                boxEntities = [];

            }
        }


        // Event listeners for the sliders
        document.getElementById('minLatSlider').addEventListener('input', function () {
            document.getElementById('minLatValue').textContent = this.value;
            updateBoxOutline(parseFloat(this.value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('maxLatSlider').addEventListener('input', function () {
            document.getElementById('maxLatValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(this.value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('minLonSlider').addEventListener('input', function () {
            document.getElementById('minLonValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(this.value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('maxLonSlider').addEventListener('input', function () {
            document.getElementById('maxLonValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(this.value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('minDepthSlider').addEventListener('input', function () {
            document.getElementById('minDepthValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(this.value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('maxDepthSlider').addEventListener('input', function () {
            document.getElementById('maxDepthValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(this.value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('alphaSlider').addEventListener('input', function () {
            document.getElementById('alphaValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(this.value));
        });

        document.getElementById('data-file').addEventListener('change', updateSlidersFromDropdown);

        // Load initial dropdown and update sliders
        loadDropdown();

        var points = [];
        var distanceDisplay = document.getElementById('distanceDisplay');
        var clearButton = document.getElementById('clearButton');
        var distanceLineEntity = null; // Reference to the distance line entity
        var pointEntities = []; // To store point entities for click locations

        function calculateDistance(point1, point2) {
            return Cesium.Cartesian3.distance(point1, point2);
        }

        function updateDistanceDisplay(distance) {
            const dist = distance / 1000.0;
            distanceDisplay.textContent = 'Distance: ' + dist.toFixed(2) + ' km';
        }

        function clearDistance() {
            points = [];
            distanceDisplay.textContent = '';

            // Remove the distance line entity
            if (distanceLineEntity) {
                viewer.entities.remove(distanceLineEntity);
                distanceLineEntity = null;
            }

            // Remove all point markers
            pointEntities.forEach(function (entity) {
                viewer.entities.remove(entity);
            });
            pointEntities = [];
        }

        var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(function (click) {
            var cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);

            if (points.length == 2) {
                clearDistance();
            }

            if (cartesian) {
                if (document.getElementById('clearCheckbox').checked) {
                    points.push(cartesian);

                    // Add a point or marker (using X symbol or just a point)
                    var pointEntity = viewer.entities.add({
                        position: cartesian,
                        point: {
                            pixelSize: 10, // Adjust size of the X marker
                            color: Cesium.Color.ORANGE,
                            outlineWidth: 1,
                            outlineColor: Cesium.Color.WHITE
                        }
                    });
                    pointEntities.push(pointEntity); // Store point entity for future removal
                }

                if (points.length == 2) {
                    var distance = calculateDistance(points[0], points[1]);
                    updateDistanceDisplay(distance);

                    // Add a new distance line
                    distanceLineEntity = viewer.entities.add({
                        polyline: {
                            positions: [points[0], points[1]], // Use the last two points
                            width: 2,
                            material: Cesium.Color.ORANGE
                        }
                    });
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        document.getElementById('clearCheckbox').addEventListener('change', function () {
            if (!this.checked) {
                clearDistance();
            }
        });


        document.getElementById('toggleGlobeCheckbox').addEventListener('change', function () {
            viewer.scene.globe.show = this.checked;
        });

        // Handling the Geojson data.
        document.addEventListener('DOMContentLoaded', function () {
            function handleGeoJsonData(checkboxId, dataArray, labelArray, colorArray, lineWidthArray, fillOpacityArray, dataSourcesArray, extraLogic) {
                var checkbox = document.getElementById(checkboxId);

                function handleData(checked) {
                    if (checked) {
                        for (var i = 0; i < dataArray.length; i++) {
                            (function (index) {
                                Cesium.GeoJsonDataSource.load(dataArray[index], {
                                    label: labelArray[index],
                                    stroke: colorArray[index],
                                    fill: colorArray[index].withAlpha(fillOpacityArray[index]),
                                    strokeWidth: lineWidthArray[index],
                                    markerSymbol: '?'
                                }).then(function (dataSource) {
                                    if (extraLogic) {
                                        extraLogic(dataSource, index);
                                    }

                                    dataSourcesArray.push(dataSource);
                                    viewer.dataSources.add(dataSource);
                                }).catch(function (error) {
                                    console.error('Error loading GeoJSON:', error);
                                });
                            })(i);
                        }
                    } else {
                        for (var i = 0; i < dataSourcesArray.length; i++) {
                            if (viewer.dataSources.contains(dataSourcesArray[i])) {
                                viewer.dataSources.remove(dataSourcesArray[i]);
                            }
                        }
                        dataSourcesArray.length = 0; // Clear the array
                    }
                }

                checkbox.addEventListener('change', function () {
                    handleData(this.checked);
                });

                handleData(checkbox.checked);
            }
            // Function to populate the dropdown menu dynamically using auxLabel array
            function populateDropdown() {
                const dropdown = document.getElementById('select2dSurface');

                // Clear existing options (if any)
                dropdown.innerHTML = '';

                // Add options from auxLabel array
                auxLabel.forEach((label, index) => {
                    const option = document.createElement('option');
                    option.value = index;  // Set value as the index in the array
                    option.textContent = label;  // Set the display text from the array
                    dropdown.appendChild(option);
                });
            }

            // Function to enforce a maximum of 2 selections
            function enforceSelectionLimit() {
                const dropdown = document.getElementById('select2dSurface');
                const selectedOptions = Array.from(dropdown.selectedOptions);

                // Enforce selection limit of 2
                if (selectedOptions.length > 2) {
                    // Deselect the latest selected option
                    selectedOptions[selectedOptions.length - 1].selected = false;
                    alert('You can only select a maximum of 2 options.');
                }
            }

            // Function to update the legend
            function updateLegend() {
                const dropdown = document.getElementById('select2dSurface');
                const selectedOptions = Array.from(dropdown.selectedOptions);
                const legend = document.getElementById('legend');

                // Clear the current legend
                legend.innerHTML = '';

                // Loop over selected options and add to legend
                let selectionIndex = -1;
                selectedOptions.forEach(option => {
                    const selectedValue = option.value;
                    selectionIndex += 1;
                    const color = auxDefaultColor[selectionIndex];  // Get the color for the selected option

                    // Create a new legend item
                    const legendItem = document.createElement('div');
                    legendItem.style.display = 'flex';
                    legendItem.style.alignItems = 'center';
                    legendItem.style.marginBottom = '5px';

                    // Create a colored box for the legend
                    const colorBox = document.createElement('div');
                    colorBox.style.width = '20px';
                    colorBox.style.height = '20px';
                    colorBox.style.backgroundColor = color.toCssColorString();  // Assuming auxColor is a Cesium Color object
                    colorBox.style.marginRight = '10px';

                    // Create a label for the legend item
                    const label = document.createElement('span');
                    label.textContent = auxLabel[selectedValue];  // Label from the auxLabel array

                    // Add the color box and label to the legend item
                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(label);

                    // Add the legend item to the legend div
                    legend.appendChild(legendItem);
                });
            }

            // Function to handle the dropdown change event
            var auxDataSources = [];

            function handleDropdownChange() {
                const dropdown = document.getElementById('select2dSurface');
                const checkbox = document.getElementById('toggle2dSurfaceCheckbox');

                // Get selected options
                const selectedOptions = Array.from(dropdown.selectedOptions);

                // Check if there are any selections
                if (selectedOptions.length > 0) {
                    checkbox.checked = true;
                } else {
                    checkbox.checked = false;
                }

                // Clear items from the last selection, if any
                for (var i = 0; i < auxDataSources.length; i++) {
                    if (viewer.dataSources.contains(auxDataSources[i])) {
                        viewer.dataSources.remove(auxDataSources[i]);
                    }
                }
                auxDataSources.length = 0; // Clear the array

                // Loop over selected options and handle each selection
                let selectionIndex = -1;
                selectedOptions.forEach(option => {
                    const selectedValue = option.value;
                    selectionIndex += 1;
                    handleGeoJsonData(
                        'toggle2dSurfaceCheckbox',
                        [auxData[selectedValue]],
                        [auxLabel[selectedValue]], // Assuming you have a label array for auxData
                        [auxDefaultColor[selectionIndex]],
                        [auxLineWidth[selectedValue]],
                        [auxFillOpacity[selectedValue]],
                        auxDataSources
                    );
                });

                // Update the legend whenever the selection changes
                updateLegend();
            }

            // Call the populateDropdown function to add the options from auxLabel array
            populateDropdown();

            // Add event listener to the dropdown
            document.getElementById('select2dSurface').addEventListener('change', function () {
                enforceSelectionLimit();
                handleDropdownChange();
            });


            // Boundary lines.
            var boundaryDataSources = [];
            handleGeoJsonData(
                'toggleBoundaryCheckbox',
                boundaryData,
                boundaryLabel, // Assuming you have a label array for boundaryData
                boundaryColor,
                boundaryLineWidth,
                boundaryFillOpacity,
                boundaryDataSources
            );

            // CFM data with additional logic
            var cfmDataSources = [];
            handleGeoJsonData(
                'toggleCFMCheckbox',
                cfmData,
                cfmLabel,
                cfmColor,
                cfmLineWidth,
                cfmFillOpacity,
                cfmDataSources,
                function (dataSource, index) {
                    var entitiesToRemove = [];
                    dataSource.entities.values.forEach(function (entity) {

                        if (Cesium.defined(entity.polygon)) {
                            var coordinates = entity.polygon.hierarchy.getValue().positions;
                            coordinates.forEach(function (coordinate) {
                                Cesium.Cartographic.fromCartesian(coordinate);
                            });
                        } else if (Cesium.defined(entity.polyline)) {
                            var positions = entity.polyline.positions.getValue();
                            positions.forEach(function (position) {
                                Cesium.Cartographic.fromCartesian(position);
                            });
                        }
                        var description = '';
                        var properties = entity.properties;
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName) && typeof properties[propertyName] !== 'function') {
                                var propNameWithoutUnderscore = propertyName.replace(/^_/, '');
                                description += propNameWithoutUnderscore + ': ' + properties[propertyName] + '<br />';
                            }
                        }
                        entity.description = description;

                    });

                    entitiesToRemove.forEach(function (entity) {
                        dataSource.entities.remove(entity);
                    });
                }
            );

            // CFM Trace data with additional logic
            var cfmTraceDataSources = [];
            handleGeoJsonData(
                'toggleCFMTraceCheckbox',
                cfmTraceData,
                cfmTraceLabel,
                cfmTraceColor,
                cfmTraceLineWidth,
                cfmTraceFillOpacity,
                cfmTraceDataSources,
                function (dataSource, index) {
                    var entitiesToRemove = [];
                    dataSource.entities.values.forEach(function (entity) {
                        // Display all.
                        if (Cesium.defined(entity.polygon)) {
                            var coordinates = entity.polygon.hierarchy.getValue().positions;
                            coordinates.forEach(function (coordinate) {
                                Cesium.Cartographic.fromCartesian(coordinate);
                            });
                        } else if (Cesium.defined(entity.polyline)) {
                            var positions = entity.polyline.positions.getValue();
                            positions.forEach(function (position) {
                                Cesium.Cartographic.fromCartesian(position);
                            });
                        }
                        var description = '';
                        var properties = entity.properties;
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName) && typeof properties[propertyName] !== 'function') {
                                var propNameWithoutUnderscore = propertyName.replace(/^_/, '');
                                description += propNameWithoutUnderscore + ': ' + properties[propertyName] + '<br />';
                            }
                        }
                        entity.description = description;

                    });

                    entitiesToRemove.forEach(function (entity) {
                        dataSource.entities.remove(entity);
                    });
                }
            );
        });

        centeredView()
    </script>
</body>

</html>